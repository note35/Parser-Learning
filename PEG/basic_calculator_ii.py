#!/usr/bin/env python3.8
# @generated by pegen from basic_calculator_ii.python.gram

import ast
import sys
import tokenize

from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger, Parser


class GeneratedParser(Parser):

    @memoize
    def start(self) -> Optional[int]:
        # start: additive
        mark = self.mark()
        cut = False
        if (
            (ret := self.additive())
        ):
            return ret
        self.reset(mark)
        if cut: return None
        return None

    @memoize_left_rec
    def additive(self) -> Optional[int]:
        # additive: additive '+' multitive | additive '-' multitive | multitive
        mark = self.mark()
        cut = False
        if (
            (lval := self.additive())
            and
            (literal := self.expect('+'))
            and
            (rval := self.multitive())
        ):
            return lval + rval
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (lval := self.additive())
            and
            (literal := self.expect('-'))
            and
            (rval := self.multitive())
        ):
            return lval - rval
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (multitive := self.multitive())
        ):
            return multitive
        self.reset(mark)
        if cut: return None
        return None

    @memoize_left_rec
    def multitive(self) -> Optional[int]:
        # multitive: multitive '*' decimal | multitive '/' decimal | decimal
        mark = self.mark()
        cut = False
        if (
            (lval := self.multitive())
            and
            (literal := self.expect('*'))
            and
            (rval := self.decimal())
        ):
            return lval * rval
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (lval := self.multitive())
            and
            (literal := self.expect('/'))
            and
            (rval := self.decimal())
        ):
            return lval // rval
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (decimal := self.decimal())
        ):
            return decimal
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def decimal(self) -> Optional[int]:
        # decimal: NUMBER
        mark = self.mark()
        cut = False
        if (
            (number := self.number())
        ):
            return int ( number . string )
        self.reset(mark)
        if cut: return None
        return None


if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main(GeneratedParser)
