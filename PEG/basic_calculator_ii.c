// @generated by pegen.py from basic_calculator_ii.c.gram
#include "pegen.h"

#if defined(Py_DEBUG) && defined(Py_BUILD_CORE)
extern int Py_DebugFlag;
#define D(x) if (Py_DebugFlag) x;
#else
#define D(x)
#endif
static const int n_keyword_lists = 0;
static KeywordToken *reserved_keywords[] = {
    (KeywordToken[]) {{NULL, -1}},
};
#define file_type 1000
#define sum_type 1001  // Left-recursive
#define term_type 1002  // Left-recursive

static mod_ty file_rule(Parser *p);
static expr_ty sum_rule(Parser *p);
static expr_ty term_rule(Parser *p);


// file: sum? $
static mod_ty
file_rule(Parser *p)
{
    D(p->level++);
    if (p->error_indicator) {
        D(p->level--);
        return NULL;
    }
    mod_ty _res = NULL;
    int _mark = p->mark;
    { // sum? $
        if (p->error_indicator) {
            D(p->level--);
            return NULL;
        }
        D(fprintf(stderr, "%*c> file[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "sum? $"));
        void *a;
        Token * endmarker_var;
        if (
            (a = sum_rule(p), 1)  // sum?
            &&
            (endmarker_var = _PyPegen_expect_token(p, ENDMARKER))  // token='ENDMARKER'
        )
        {
            D(fprintf(stderr, "%*c+ file[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "sum? $"));
            _res = _PyPegen_make_module ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                D(p->level--);
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s file[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "sum? $"));
    }
    _res = NULL;
  done:
    D(p->level--);
    return _res;
}

// Left-recursive
// sum: sum '+' term | sum '-' term | term
static expr_ty sum_raw(Parser *);
static expr_ty
sum_rule(Parser *p)
{
    D(p->level++);
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, sum_type, &_res)) {
        D(p->level--);
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_0 = _PyPegen_update_memo(p, _mark, sum_type, _res);
        if (tmpvar_0) {
            D(p->level--);
            return _res;
        }
        p->mark = _mark;
        void *_raw = sum_raw(p);
        if (p->error_indicator)
            return NULL;
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    D(p->level--);
    return _res;
}
static expr_ty
sum_raw(Parser *p)
{
    D(p->level++);
    if (p->error_indicator) {
        D(p->level--);
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        D(p->level--);
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // sum '+' term
        if (p->error_indicator) {
            D(p->level--);
            return NULL;
        }
        D(fprintf(stderr, "%*c> sum[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "sum '+' term"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = sum_rule(p))  // sum
            &&
            (_literal = _PyPegen_expect_token(p, 14))  // token='+'
            &&
            (b = term_rule(p))  // term
        )
        {
            D(fprintf(stderr, "%*c+ sum[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "sum '+' term"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                D(p->level--);
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_BinOp ( a , Add , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                D(p->level--);
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s sum[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "sum '+' term"));
    }
    { // sum '-' term
        if (p->error_indicator) {
            D(p->level--);
            return NULL;
        }
        D(fprintf(stderr, "%*c> sum[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "sum '-' term"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = sum_rule(p))  // sum
            &&
            (_literal = _PyPegen_expect_token(p, 15))  // token='-'
            &&
            (b = term_rule(p))  // term
        )
        {
            D(fprintf(stderr, "%*c+ sum[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "sum '-' term"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                D(p->level--);
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_BinOp ( a , Sub , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                D(p->level--);
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s sum[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "sum '-' term"));
    }
    { // term
        if (p->error_indicator) {
            D(p->level--);
            return NULL;
        }
        D(fprintf(stderr, "%*c> sum[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "term"));
        expr_ty term_var;
        if (
            (term_var = term_rule(p))  // term
        )
        {
            D(fprintf(stderr, "%*c+ sum[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "term"));
            _res = term_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s sum[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "term"));
    }
    _res = NULL;
  done:
    D(p->level--);
    return _res;
}

// Left-recursive
// term: term '*' NUMBER | term '/' NUMBER | NUMBER
static expr_ty term_raw(Parser *);
static expr_ty
term_rule(Parser *p)
{
    D(p->level++);
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, term_type, &_res)) {
        D(p->level--);
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_1 = _PyPegen_update_memo(p, _mark, term_type, _res);
        if (tmpvar_1) {
            D(p->level--);
            return _res;
        }
        p->mark = _mark;
        void *_raw = term_raw(p);
        if (p->error_indicator)
            return NULL;
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    D(p->level--);
    return _res;
}
static expr_ty
term_raw(Parser *p)
{
    D(p->level++);
    if (p->error_indicator) {
        D(p->level--);
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        D(p->level--);
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // term '*' NUMBER
        if (p->error_indicator) {
            D(p->level--);
            return NULL;
        }
        D(fprintf(stderr, "%*c> term[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "term '*' NUMBER"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = term_rule(p))  // term
            &&
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (b = _PyPegen_number_token(p))  // NUMBER
        )
        {
            D(fprintf(stderr, "%*c+ term[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "term '*' NUMBER"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                D(p->level--);
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_BinOp ( a , Mult , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                D(p->level--);
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s term[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "term '*' NUMBER"));
    }
    { // term '/' NUMBER
        if (p->error_indicator) {
            D(p->level--);
            return NULL;
        }
        D(fprintf(stderr, "%*c> term[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "term '/' NUMBER"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = term_rule(p))  // term
            &&
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            (b = _PyPegen_number_token(p))  // NUMBER
        )
        {
            D(fprintf(stderr, "%*c+ term[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "term '/' NUMBER"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                D(p->level--);
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _Py_BinOp ( a , FloorDiv , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                D(p->level--);
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s term[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "term '/' NUMBER"));
    }
    { // NUMBER
        if (p->error_indicator) {
            D(p->level--);
            return NULL;
        }
        D(fprintf(stderr, "%*c> term[%d-%d]: %s\n", p->level, ' ', _mark, p->mark, "NUMBER"));
        expr_ty number_var;
        if (
            (number_var = _PyPegen_number_token(p))  // NUMBER
        )
        {
            D(fprintf(stderr, "%*c+ term[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NUMBER"));
            _res = number_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s term[%d-%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, "NUMBER"));
    }
    _res = NULL;
  done:
    D(p->level--);
    return _res;
}

void *
_PyPegen_parse(Parser *p)
{
    // Initialize keywords
    p->keywords = reserved_keywords;
    p->n_keyword_lists = n_keyword_lists;

    // Run parser
    void *result = NULL;
    if (p->start_rule == Py_file_input) {
        result = file_rule(p);
    } else if (p->start_rule == Py_single_input) {
        result = interactive_rule(p);
    } else if (p->start_rule == Py_eval_input) {
        result = eval_rule(p);
    } else if (p->start_rule == Py_func_type_input) {
        result = func_type_rule(p);
    } else if (p->start_rule == Py_fstring_input) {
        result = fstring_rule(p);
    }

    return result;
}

// The end
